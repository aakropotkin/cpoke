// sed -e 's///g' -e 's///g' -e 's/;/;/g' <include/all.E >include/all.E2

//__FROM__: include/util/test_util.h

//__FROM__: include/util/macros.h

//__FROM__: include/util/files.h
bool file_exists( const char * fpath );
long file_size( const char * fpath );
size_t fread_malloc( const char * fpath, char ** buffer );

//__FROM__: include/util/fnmacros.h

//__FROM__: include/util/enumflags.h

//__FROM__: include/util/bits.h
/*
static inline void
lshowbits ( unsigned long ul ) {
  for ( int i = 8 * sizeof( unsigned long ) -1; i >= 0; i-- )
    printf( "%lu", ( ul >> i ) & 1 );
  putchar( '\n' );
}

  static inline void
ishowbits ( unsigned int ui ) {
  for ( int j = 8 * sizeof( unsigned int ) -1; j >= 0; j-- )
    printf( "%u", ( ui >> j ) & 1 );
  putchar( '\n' );
}
*/
  static unsigned char
log10_u32( unsigned int x );





  static int
atoin( const char * str, unsigned char n );






  static unsigned int
atouin( const char * str, unsigned char n );





  static char
atocn( const char * str, unsigned char n );





  static unsigned char
atoucn( const char * str, unsigned char n );

//__FROM__: include/test.h







bool test_json( void );
bool test_pokemon( void );
bool test_ptypes( void );
bool test_parse_gm( void );
bool test_cstore( void );
bool test_player( void );
bool test_battle( void );
bool test_naive_ai( void );
bool test_filter( void );
bool test_fuzzy( void );
bool test_all( void );
//__FROM__: include/store.h
struct store_s;




typedef enum {
  STORE_NULL_STATUS,
  STORE_SUCCESS,
  STORE_ERROR_FAIL,
  STORE_ERROR_BAD_VALUE,
  STORE_ERROR_NOMEM,
  STORE_ERROR_NOT_FOUND,
  STORE_ERROR_NOT_WRITABLE,
  STORE_ERROR_NOT_DEFINED
} store_status_t;



//@@
/*
DEFINE_ENUM_WITH_FLAGS( store_flag,
    SF_NONE, SF_WRITABLE, SF_THREAD_SAFE, SF_OFFICIAL_DATA, SF_CUSTOM_DATA,
    SF_EXPORTABLE, SF_STANDARD_KEY, SF_TYPED, SF_GET_STRING,
    SF_GET_TYPED_STRING
  );
*/
typedef enum {    SF_NONE, SF_WRITABLE, SF_THREAD_SAFE, SF_OFFICIAL_DATA, SF_CUSTOM_DATA,
    SF_EXPORTABLE, SF_STANDARD_KEY, SF_TYPED, SF_GET_STRING,
    SF_GET_TYPED_STRING} store_flag_t;
typedef unsigned int store_flag_mask_t;


typedef enum  {
  STORE_UNKNOWN,
  STORE_STRING,
  STORE_NUM,
  STORE_FUNCTION,
  STORE_POKEDEX,
  STORE_MOVE,
  STORE_ROSTER,
  STORE_CUP,
  STORE_PVP_POKEMON,
  STORE_PVP_TEAM,
  STORE_PVP_BATTLE,
  STORE_PVP_BATTLE_LOG,
  STORE_PVP_POKEMON_RANKING,
  STORE_PVP_MOVE_RANKING,
  STORE_ANALYTICS,
  STORE_CUSTOM
} store_type_t;





typedef enum {
  SS_UNKNOWN, SS_C, SS_JSON, SS_SQL
} store_sink_t;

static const char * STORE_SINK_NAMES[];




struct store_key_s {
  store_type_t key_type;
  store_type_t val_type;
  union {
    uint32_t data_f;
    struct {
      union { uint16_t data_h0; struct { uint8_t data_q0, data_q1; }; };
      union { uint16_t data_h1; struct { uint8_t data_q2, data_q3; }; };
    };
  } ;
};
typedef struct store_key_s store_key_t;
typedef bool ( * store_has_fn )( struct store_s *, store_key_t );
typedef int ( * store_get_fn )( struct store_s *, store_key_t, void ** );
typedef int ( * store_init_fn )( struct store_s *, void * );
typedef void ( * store_free_fn )( struct store_s * );


typedef int ( * store_get_str_fn )( struct store_s *, const char *, void ** );

typedef int ( * store_get_str_t_fn )( struct store_s *,
                                       store_type_t,
                                       const char *,
                                       void **
                                     );

typedef int ( * store_add_fn )( struct store_s *, store_key_t, void * );
typedef int ( * store_set_fn )( struct store_s *, store_key_t, void * );

typedef int ( * store_export_fn )( struct store_s *, store_sink_t, void * );




struct store_s {
  char * name;
  store_flag_mask_t flags;
  store_has_fn has;
  store_get_fn get;
  store_get_str_fn get_str;
  store_get_str_t_fn get_str_t;
  store_add_fn add;
  store_set_fn set;
  store_export_fn export;
  store_init_fn init;
  store_free_fn free;
  void * aux;
};

typedef struct store_s store_t;
//__FROM__: include/pvp_action.h
//@@
/*
DEFINE_ENUM_WITH_FLAGS( pvp_action,
    ACT_NULL, FAST, WAIT, CHARGED1, CHARGED2, SWITCH1, SWITCH2, SHIELD
  );
*/
typedef enum { ACT_NULL, FAST, WAIT, CHARGED1, CHARGED2, SWITCH1, SWITCH2, SHIELD} pvp_action_t;

typedef unsigned int pvp_action_mask_t;
static const uint8_t NUM_PVP_ACTIONS;
static const char * PVP_ACTION_NAMES[];

//__FROM__: include/ptypes.h
static const float WEAK_DMG_MOD;
static const float RESIST_DMG_MOD;
static const float IMMUNE_DMG_MOD;
static const float STAB_DMG_MOD;
//@@
/*
DEFINE_ENUM_WITH_FLAGS( ptype, PT_NONE, BUG, DARK, DRAGON, ELECTRIC, FAIRY,
                        FIGHTING, FIRE, FLYING, GHOST, GRASS, GROUND, ICE,
                        NORMAL, POISON, PSYCHIC, ROCK, STEEL, WATER
                      );
*/
typedef enum { PT_NONE , BUG , DARK , DRAGON , ELECTRIC , FAIRY , FIGHTING , FIRE, FLYING , GHOST , GRASS , GROUND , ICE , NORMAL , POISON , PSYCHIC , ROCK , STEEL , WATER } ptype_t;
typedef unsigned int ptype_mask_t;
typedef union { ptype_mask_t mask; struct { unsigned int BUG : 1 ; unsigned int DARK : 1 ; unsigned int DRAGON : 1 ; unsigned int ELECTRIC : 1 ; unsigned int FAIRY : 1 ; unsigned int FIGHTING : 1 ; unsigned int FIRE : 1 ; unsigned int FLYING : 1 ; unsigned int GHOST : 1 ; unsigned int GRASS : 1 ; unsigned int GROUND : 1 ; unsigned int ICE : 1 ; unsigned int NORMAL : 1 ; unsigned int POISON : 1 ; unsigned int PSYCHIC : 1 ; unsigned int ROCK : 1 ; unsigned int STEEL : 1 ; unsigned int WATER : 1; }; } ptype_flags_t;
static const uint8_t NUM_PTYPES;

int fprint_ptype_mask( FILE * fd, const char * sep, ptype_mask_t pm );
struct ptype_traits_s {
  ptype_mask_t resistances : 18;
  ptype_mask_t weaknesses : 18;
  ptype_mask_t immunities : 18;
} ;

typedef struct ptype_traits_s ptype_traits_t;
 float get_damage_modifier_mono( ptype_t def_type, ptype_t atk_type );
 float get_damage_modifier_duo( ptype_t def_type1,
                                        ptype_t def_type2,
                                        ptype_t atk_type
                                      );

 float get_damage_modifier( ptype_mask_t def_types, ptype_t atk_type );

 float
get_damage_modifier_flags( ptype_flags_t def_types, ptype_t atk_type );



/*
  static inline  bool
pt_resistp( ptype_t def, ptype_t atk )
{
  return ( !! ( ( ptype_traits[( ( def ) )].resistances ) &
                ( ( (ptype_mask_t) to_mask( ( ( atk ) ) ) ) ) ) );
}

  static inline  bool
pt_weakp( ptype_t def, ptype_t atk )
{
  return ( !! ( ( ptype_traits[( ( def ) )].weaknesses ) &
                ( ( (ptype_mask_t) to_mask( ( ( atk ) ) ) ) ) ) );
}

  static inline  bool
pt_immunep( ptype_t def, ptype_t atk )
{
  return ( !! ( ( ptype_traits[( ( def ) )].immunities ) &
                ( ( (ptype_mask_t) to_mask( ( ( atk ) ) ) ) ) ) );
}
*/


static const char * PTYPE_NAMES[];

//__FROM__: include/ext/uthash.h
typedef struct UT_hash_bucket {
   struct UT_hash_handle *hh_head;
   unsigned count;
   unsigned expand_mult;

} UT_hash_bucket;





typedef struct UT_hash_table {
   UT_hash_bucket *buckets;
   unsigned num_buckets, log2_num_buckets;
   unsigned num_items;
   struct UT_hash_handle *tail;
   ptrdiff_t hho;



   unsigned ideal_chain_maxlen;




   unsigned nonideal_items;







   unsigned ineff_expands, noexpand;

   uint32_t signature;






} UT_hash_table;

typedef struct UT_hash_handle {
   struct UT_hash_table *tbl;
   void *prev;
   void *next;
   struct UT_hash_handle *hh_prev;
   struct UT_hash_handle *hh_next;
   void *key;
   unsigned keylen;
   unsigned hashv;
} UT_hash_handle;

//__FROM__: include/hash.h
static const UT_hash_handle HH_NULL;

//__FROM__: include/moves.h
typedef enum  {
  bc_1000, bc_0500, bc_0300, bc_0125, bc_0100, bc_0000
} buff_chance_t;




struct stat_buff_s {
  uint8_t target : 1;
  uint8_t debuffp : 1;
  uint8_t amount : 2;
} ;
typedef struct stat_buff_s stat_buff_t;

/*
  static inline  int8_t
decode_stat_buff( stat_buff_t buff )
{
  return buff.debuffp ? buff.amount : ( - buff.amount );
}
*/



struct buff_s {
  buff_chance_t chance;
  stat_buff_t atk_buff;
  stat_buff_t def_buff;
} ;
typedef struct buff_s buff_t;


static const buff_t NO_BUFF;
static const float BUFF_MOD[];

typedef enum  {
  B_4_8, B_4_7, B_4_6, B_4_5,
  B_4_4,
  B_5_4, B_6_4, B_7_4, B_8_4
} buff_level_t;




struct buff_state_s {
  buff_level_t atk_buff_lv;
  buff_level_t def_buff_lv;
} ;
typedef struct buff_state_s buff_state_t;

static const buff_state_t NO_BUFF_STATE;



void apply_buff( buff_state_t * buff_state, buff_t buff );







struct base_move_s {
  uint16_t move_id;
  ptype_t type;
  bool is_fast : 1;
  uint8_t power;
  uint8_t energy;
} ;
typedef struct base_move_s base_move_t;

static const base_move_t NO_MOVE;
struct pve_move_s {
  base_move_t base_move; //@@
  uint16_t cooldown;
} ;
typedef struct pve_move_s pve_move_t;

static const pve_move_t NO_MOVE_PVE;

int pve_move_from_store( store_t * store,
                         uint16_t move_id,
                         pve_move_t * move
                       );




struct pvp_charged_move_s {
  base_move_t base_move; //@@
  buff_t buff;
} ;
typedef struct pvp_charged_move_s pvp_charged_move_t;

static const pvp_charged_move_t NO_MOVE_PVP_CHARGED;

int pvp_charged_move_from_store( store_t * store,
                                 uint16_t move_id,
                                 pvp_charged_move_t * move
                               );




struct pvp_fast_move_s {
  base_move_t base_move; //@@
  uint8_t turns : 2;
} ;
typedef struct pvp_fast_move_s pvp_fast_move_t;

static const pvp_fast_move_t NO_MOVE_PVP_FAST;

int pvp_fast_move_from_store( store_t * store,
                              uint16_t move_id,
                              pvp_fast_move_t * move
                            );
struct store_move_s {
  char * name;
  ptype_t type;
  bool is_fast : 1;
  uint16_t move_id;
  uint16_t cooldown;
  uint8_t pve_power;
  uint8_t pvp_power;
  uint8_t pve_energy;
  uint8_t pvp_energy;
  buff_t buff;
  UT_hash_handle hh_name;
  UT_hash_handle hh_move_id;
};
typedef struct store_move_s store_move_t;

static const store_move_t NO_MOVE_STORE;



/*
  static inline store_key_t
move_store_key( store_move_t * move )
{
  return (store_key_t) {
    .key_type = STORE_NUM,
    .val_type = STORE_MOVE,
    .data_h0 = move->move_id,
    .data_h1 = 0
  };
}

  static inline store_key_t
move_id_store_key( uint16_t move_id )
{
  return (store_key_t) {
    .key_type = STORE_NUM,
    .val_type = STORE_MOVE,
    .data_h0 = max( move_id, - move_id ),
    .data_h1 = 0
  };
}




  static inline pve_move_t
pve_move_from_store_move( store_move_t * stored )
{
  assert( stored != NULL );
  pve_move_t move = {
    .move_id = stored->move_id,
    .type = stored->type,
    .is_fast = stored->is_fast,
    .power = stored->pve_power,
    .energy = stored->pve_energy,
    .cooldown = stored->cooldown
  };
  return move;
}

  static inline pvp_charged_move_t
pvp_charged_move_from_store_move( store_move_t * stored )
{
  assert( stored != NULL );
  pvp_charged_move_t move = {
    .move_id = stored->move_id,
    .type = stored->type,
    .is_fast = stored->is_fast,
    .power = stored->pvp_power,
    .energy = stored->pvp_energy,
    .buff = stored->buff
  };
  return move;
}

  static inline pvp_fast_move_t
pvp_fast_move_from_store_move( store_move_t * stored )
{
  assert( stored != NULL );
  pvp_fast_move_t move = {
    .move_id = stored->move_id,
    .type = stored->type,
    .is_fast = stored->is_fast,
    .power = stored->pvp_power,
    .energy = stored->pvp_energy,
    .turns = stored->cooldown
  };
  return move;
}
*/



int fprint_buff( FILE * stream, const buff_t * buff );


int fprint_buff_json( FILE * stream, const buff_t * buff );


int fprint_buff_c( FILE * stream, const buff_t * buff );





int fprint_store_move( FILE * stream, const store_move_t * move );


int fprint_store_move_json( FILE * stream, const store_move_t * move );


int fprint_store_move_c( FILE * stream, const store_move_t * move );
//__FROM__: include/pokedex.h
static const uint16_t MAX_STAT;

struct stats_s { uint16_t attack, stamina, defense; } ;
typedef struct stats_s stats_t;



//@@
/*
DEFINE_ENUM_WITH_FLAGS( pdex_tag, TAG_NONE, TAG_LEGENDARY, TAG_MYTHIC, TAG_MEGA,
                        TAG_SHADOW_ELIGABLE, TAG_SHADOW, TAG_PURE,
                        TAG_ALOLAN, TAG_GALARIAN,
                        TAG_STARTER, TAG_REGIONAL
                      );
*/
typedef enum { TAG_NONE, TAG_LEGENDARY, TAG_MYTHIC, TAG_MEGA,
                        TAG_SHADOW_ELIGABLE, TAG_SHADOW, TAG_PURE,
                        TAG_ALOLAN, TAG_GALARIAN,
                        TAG_STARTER, TAG_REGIONAL } pdex_tag_t;
typedef unsigned int pdex_tag_mask_t;

static const char * PDEX_TAG_NAMES[];





int fprint_pdex_tag_mask( FILE * fd, const char * sep, pdex_tag_mask_t tm );







struct region_s {
  char * name;
  uint16_t dex_start;
  uint16_t dex_end;
};
typedef struct region_s region_t;


static const region_t REGIONS[];

typedef enum {
  R_KANTO = 0,
  R_JOHTO,
  R_HOENN,
  R_SINNOH,
  R_UNOVA,
  R_KALOS,
  R_UNKNOWN
} region_e;
static const region_t * REGION_KANTO;
static const region_t * REGION_JOHTO;
static const region_t * REGION_HOENN;
static const region_t * REGION_SINNOH;
static const region_t * REGION_UNOVA;
static const region_t * REGION_KALOS;
static const region_t * REGION_UNKNOWN;




struct pdex_mon_s {
  uint16_t dex_number;
  char * name;

  char * form_name;

  uint16_t family;
  ptype_mask_t types;
  stats_t base_stats;
  pdex_tag_mask_t tags;
  int16_t * fast_move_ids;
  uint8_t fast_moves_cnt;
  int16_t * charged_move_ids;
  uint8_t charged_moves_cnt;
  uint8_t form_idx;
  struct pdex_mon_s * next_form;

  UT_hash_handle hh_name;
  UT_hash_handle hh_dex_num;
};
typedef struct pdex_mon_s pdex_mon_t;

static const pdex_mon_t PDEX_NULL;




static const uint16_t MAX_DEX;

void pdex_mon_init( pdex_mon_t * mon,
                    uint16_t dex_num,
                    const char * name,
                    size_t name_len,
                    uint16_t family,
                    uint8_t form_num,
                    ptype_t type1,
                    ptype_t type2,
                    uint16_t stamina,
                    uint16_t attack,
                    uint16_t defense,
                    pdex_tag_mask_t tags,
                    int16_t * fast_move_ids,
                    uint8_t fast_moves_cnt,
                    int16_t * charged_move_ids,
                    uint8_t charged_moves_cnt
                  );
void pdex_mon_free( pdex_mon_t * mon );

/*
  static inline store_key_t
pdex_store_key( pdex_mon_t * mon )
{
  return (store_key_t) {
    .key_type = STORE_NUM,
    .val_type = STORE_POKEDEX,
    .data_h0 = mon->dex_number,
    .data_q2 = mon->form_idx,
    .data_q3 = 0
  };
}

  static inline store_key_t
dex_form_store_key( uint16_t dex_num, uint8_t form_idx )
{
  return (store_key_t) {
    .key_type = STORE_NUM,
    .val_type = STORE_POKEDEX,
    .data_h0 = dex_num,
    .data_q2 = form_idx,
    .data_q3 = 0
  };
}
*/



int fprint_pdex_mon( FILE * stream, const pdex_mon_t * mon );
int fprint_pdex_mon_json( FILE * stream, const pdex_mon_t * mon );
int fprint_pdex_mon_c( FILE * stream, const pdex_mon_t * mon );
int cmp_pdex_mon( pdex_mon_t * a, pdex_mon_t * b );
int cmp_pdex_mon_practical( pdex_mon_t * a, pdex_mon_t * b );



/*
  static inline const region_t *
get_region( uint16_t dex_number )
{
  for ( uint8_t r = 0; r < NUM_REGIONS; r++ )
    {
      if ( in_eq( REGIONS[r].dex_start, dex_number, REGIONS[r].dex_end ) )
        {
          return REGIONS + r;
        }
    }
  return REGIONS + NUM_REGIONS - 1;
}




  static inline bool
is_starter( uint16_t dex_number )
{

  for ( uint8_t r = 0; r < NUM_REGIONS - 1; r++ )
    {
      if ( in_eq( REGIONS[r].dex_start, dex_number, REGIONS[r].dex_start + 9 ) )
        {
          return true;
        }
    }
  return false;
}

  static inline bool
is_regional( uint16_t dex_number )
{
  for ( uint8_t i = 0; i < NUM_REGIONALS; i++ )
    {
      if ( REGIONALS[i] == dex_number ) return true;
    }
  return false;
}
*/
static const uint16_t REGIONALS[];
static const uint8_t NUM_REGIONALS;

//__FROM__: include/ai/ai.h
struct pvp_battle_s;
struct roster_s;
struct pvp_pokemon_s;
struct store_s;




typedef enum {
  AI_NULL_STATUS,
  AI_SUCCESS,
  AI_ERROR_FAIL,
  AI_ERROR_BAD_VALUE,
  AI_ERROR_NOMEM
} ai_status_t;




struct ai_s;
typedef ai_status_t ( * decide_action_fn ) ( bool,
                                             const struct pvp_battle_s *,
                                             pvp_action_t *,
                                             void *
                                           );

typedef ai_status_t ( * select_team_fn ) ( struct roster_s *,
                                           struct roster_s *,
                                           struct pvp_pokemon_s *,
                                           struct store_s *,
                                           void *
                                         );

typedef ai_status_t ( * ai_init_fn ) ( struct ai_s *, void * );
typedef void ( * ai_free_fn ) ( struct ai_s * );




struct ai_s {
  char * name;
  select_team_fn select_team;
  decide_action_fn decide_action;
  ai_init_fn init;
  ai_free_fn free;
  void * aux;
};
typedef struct ai_s ai_t;
//__FROM__: include/battle.h
struct pvp_player_s;
static const float PVP_FAST_BONUS_MOD;
static const float PVP_CHARGE_BONUS_MOD;





static const float CHARGE_BASE_MOD;
static const float CHARGE_NICE_MOD;
static const float CHARGE_GREAT_MOD;
static const float CHARGE_EXCELLENT_MOD;




static const float STAB_BONUS;
static const float SHADOW_ATTACK_MOD;
static const float SHADOW_DEFENSE_MOD;


static const uint8_t MAX_CHARGE;

static const uint8_t CHARGE_RATE;
static const float CHARGE_DECAY_RATE;





static const uint32_t BATTLE_TIME;
static const uint16_t TURN_TIME;


static const uint16_t CHARGED_ANIM_TIME;

static const uint16_t CHARGED_MG_TIME;


static const uint16_t CHARGED_TIME;


static const uint16_t SWITCH_ANIM_TIME;

static const uint16_t SWITCH_TIMEOUT;

static const uint16_t SWITCH_TIME;


static const uint16_t BATTLE_TURNS;

static const uint8_t CHARGED_ANIM_TURNS;
static const uint8_t CHARGED_MG_TURNS;
static const uint8_t CHARGED_TURNS;

static const uint8_t SWITCH_ANIM_TURNS;
static const uint8_t SWITCH_TIMEOUT_TURNS;
static const uint8_t SWITCH_TURNS;




typedef enum {
  GREAT_LEAGUE = 1500,
  ULTRA_LEAGUE = 2500,
  MASTER_LEAGUE = 10000
} league_t;
static const char * LEAGUE_NAMES[];
typedef enum  { SIMULATE, EMULATE } battle_mode_t;
typedef enum  { FIRST_FAINT, BOTH_FAINT } battle_end_cond_t;
typedef enum  {
  CMP_IDEAL, CMP_ALTERNATE, CMP_FAVOR_P1, CMP_FAVOR_P2
} cmp_rule_t;
typedef enum  {
  COUNTDOWN,
  NEUTRAL,
  SUSPEND_CHARGED,
  SUSPEND_CHARGED_ATTACK,
  SUSPEND_CHARGED_SHIELD,
  SUSPEND_CHARGED_NO_SHIELD,
  SUSPEND_SWITCH_P1,
  SUSPEND_SWITCH_P2,
  SUSPEND_SWITCH_TIE,
  GAME_OVER
} battle_phase_t;
struct pvp_pokemon_log_s {
  uint32_t total_damage;
  uint32_t total_charged_damage;
  uint32_t total_damage_blocked;
  uint32_t total_energy_gained;
  uint32_t total_energy_used;
  uint32_t damage_against_shields;
  uint8_t damage_through_shields;
  uint8_t shields_used : 2;
  uint8_t shields_hit : 2;
  uint8_t switch_advantages;
} ;

typedef struct pvp_pokemon_log_s pvp_pokemon_log_t;

typedef pvp_pokemon_log_t pvp_team_log_t[3];

void pvp_pokemon_log_init( pvp_pokemon_log_t * pokemon_log );
void pvp_pokemon_log_free( pvp_pokemon_log_t * pokemon_log );
struct pvp_battle_s {
  struct pvp_player_s * p1;
  struct pvp_player_s * p2;
  pvp_action_t p1_action;
  pvp_action_t p2_action;
  uint32_t turn;
  battle_phase_t phase;
  cmp_rule_t cmp_rule;
  uint8_t cmp_alt_state : 1;
} ;
typedef struct pvp_battle_s pvp_battle_t;

static const pvp_battle_t PVP_BATTLE_NULL;




void pvp_battle_init( pvp_battle_t * battle );
void pvp_battle_free( pvp_battle_t * battle );
void pvp_battle_reset( pvp_battle_t * battle );




pvp_action_t decide_action( bool decide_p1, const pvp_battle_t * battle );

uint32_t simulate_battle( pvp_battle_t * battle );




bool eval_turn( pvp_battle_t * battle );

bool is_battle_over( pvp_battle_t * battle );

bool is_p1_winner( pvp_battle_t * battle );

struct pvp_player_s * get_battle_winner( pvp_battle_t * battle );







pvp_action_mask_t valid_actions( bool decide_p1, pvp_battle_t * battle );
bool is_valid_action( bool decide_p1,
                                   pvp_action_t action,
                                   pvp_battle_t * battle
                                 );

bool is_p1_cmp_winner( pvp_battle_t * battle );
//__FROM__: include/pokemon.h
static const float MAX_LEVEL;






struct base_pokemon_s {
  const pdex_mon_t * pdex_mon;
  float level;
  stats_t ivs;
};
typedef struct base_pokemon_s base_pokemon_t;

static const base_pokemon_t BASE_MON_NULL;






int base_mon_from_store( store_t * store,
                         uint16_t dex_num,
                         uint8_t form_idx,
                         float level,
                         uint16_t attack,
                         uint16_t stamina,
                         uint16_t defense,
                         base_pokemon_t * mon
                       );
struct roster_pokemon_s {
  base_pokemon_t * base;
  uint16_t fast_move_id;
  uint16_t charged_move_ids[2];
} ;
typedef struct roster_pokemon_s roster_pokemon_t;

static const roster_pokemon_t ROSTER_MON_NULL;

typedef enum { M_CHARGED1, M_CHARGED2, M_FAST } pmove_idx_t;
struct roster_s {
  roster_pokemon_t * roster_pokemon;
  size_t roster_length;
};
typedef struct roster_s roster_t;

roster_t * roster_append( roster_t * roster, roster_pokemon_t * mon );
struct pvp_pokemon_s {
  uint8_t level;
  stats_t stats;
  ptype_mask_t types;
  uint16_t hp;
  uint8_t cooldown;
  uint8_t energy;
  buff_state_t buffs;
  pvp_fast_move_t fast_move;
  pvp_charged_move_t charged_moves[2];
} ;
typedef struct pvp_pokemon_s pvp_pokemon_t;

static const pvp_pokemon_t PVP_MON_NULL;

void pvp_pokemon_init( pvp_pokemon_t * mon,
                       roster_pokemon_t * rmon,
                       store_t * store
                     );
 uint16_t get_cp_from_stats( stats_t base, stats_t ivs, float level );
 stats_t get_effective_stats( stats_t base, stats_t ivs, float level );
 uint16_t get_hp_from_stam_lv( uint16_t stam, float lv );

uint16_t get_pvp_damage( pmove_idx_t attack_idx,
                         pvp_pokemon_t * attacker,
                         pvp_pokemon_t * defender
                       );



/*
static inline bool _is_alive_ptr( pvp_pokemon_t * mon ) { return !! mon->hp; }
static inline bool _is_alive_raw( pvp_pokemon_t mon ) { return !! mon.hp; }
  static inline int
cmp_stats( stats_t a, stats_t b )
{
  uint32_t sa = a.attack + a.stamina + a.defense;
  uint32_t sb = b.attack + b.stamina + b.defense;
  if ( sa != sb )
    {
      return ( sa > sb ) - ( sa < sb );
    }
  if ( a.attack != b.attack )
    {
      return ( a.attack > b.attack ) - ( a.attack < b.attack );
    }
  if ( a.defense != b.defense )
    {
      return ( a.defense > b.defense ) - ( a.defense < b.defense );
    }
  return ( a.stamina > b.stamina ) - ( a.stamina < b.stamina );
}
*/



bool brute_maximize_ivs( uint16_t cp_cap,
                         stats_t base,
                         stats_t * ivs,
                         float * lv
                       );
/*
static inline bool
maximize_ivs( uint16_t cp_cap, stats_t base, stats_t * ivs, float * lv )
{
  return brute_maximize_ivs( cp_cap, base, ivs, lv );
}
*/
//__FROM__: include/player.h
struct player_s {
  roster_t roster;
  uint16_t wins;
  uint16_t battles;
} ;
typedef struct player_s player_t;




struct pvp_player_s {
  ai_t * ai;
  pvp_pokemon_t team[3];
  uint16_t active_pokemon : 2;
  uint16_t shields : 2;
  uint16_t switch_turns : 5;
} ;
typedef struct pvp_player_s pvp_player_t;

static const pvp_player_t PVP_PLAYER_NULL;
/*
  static inline uint8_t
_get_rem_mons_ptr( pvp_player_t * player )
{
  return ( ( !! player->team[0].hp ) + ( !! player->team[1].hp ) +
           ( !! player->team[2].hp ) );
}

  static inline uint8_t
_get_rem_mons_raw( pvp_player_t player )
{
  return ( ( !! player.team[0].hp ) + ( !! player.team[1].hp ) +
           ( !! player.team[2].hp ) );
}
*/
bool use_shield( pvp_player_t * player );
//__FROM__: include/gm_store.h
struct gm_store_aux_s {
  uint16_t mons_cnt;
  uint16_t moves_cnt;
  pdex_mon_t * mons_by_name;
  pdex_mon_t * mons_by_dex;
  store_move_t * moves_by_name;
  store_move_t * moves_by_id;
};
typedef struct gm_store_aux_s gm_store_aux_t;



typedef store_t gm_store_t;




union gm_store_key_u {
  store_key_t store_key;
  struct {
    store_type_t key_type;
    store_type_t val_type;
    uint16_t id;
    uint8_t form_idx;
    uint32_t : 0;
  };
} ;
typedef union gm_store_key_u gm_store_key_t;



/*
  static inline gm_store_key_t
dex_form_to_gmskey( uint16_t dex_num, uint8_t form_idx )
{
  return (gm_store_key_t) {
    .key_type = STORE_NUM,
    .val_type = STORE_POKEDEX,
    .id = dex_num,
    .form_idx = form_idx
  };
}

  static inline gm_store_key_t
move_id_to_gmskey( uint16_t move_id )
{
  return (gm_store_key_t) {
    .key_type = STORE_NUM,
    .val_type = STORE_MOVE,
    .id = move_id,
    .form_idx = 0
  };
}
*/






bool gm_store_has( store_t * gm_store, store_key_t key );
int gm_store_get( store_t * gm_store, store_key_t key, void ** val );
int gm_store_get_str( store_t * gm_store, const char *, void ** val );
int gm_store_get_str_t( store_t * gm_store,
                         store_type_t val_type,
                         const char * key,
                         void ** val
                       );
int gm_store_add( store_t * gm_store, store_key_t key, void * val );
int gm_store_set( store_t * gm_store, store_key_t key, void * val );
int gm_store_init( store_t * gm_store, void * vgm_parser );
void gm_store_free( store_t * gm_store );




int gm_store_get_pokemon( gm_store_t * gm_store,
                          uint16_t dex_num,
                          uint8_t form_idx,
                          pdex_mon_t ** mon
                        );

int gm_store_get_pokemon_by_name( gm_store_t * gm_store,
                                  const char * name,
                                  pdex_mon_t ** mon
                                );




int gm_store_get_move( gm_store_t * gm_store,
                       uint16_t move_id,
                       store_move_t ** move
                     );

int gm_store_get_move_by_name( gm_store_t * gm_store,
                               const char * name,
                               store_move_t ** move
                             );



int gm_store_export( gm_store_t * gm_store,
                     store_sink_t sink_type,
                     void * target
                   );

int gm_store_export_json( gm_store_t * gm_store, FILE * ostream );
int gm_store_export_c( gm_store_t * gm_store, FILE * ostream );
int gm_store_export_sql( gm_store_t * gm_store, const char * db_name );
//__FROM__: include/cstore.h
struct cstore_aux_s {
  uint16_t mons_cnt;
  uint16_t moves_cnt;
  pdex_mon_t * mons_by_name;
  store_move_t * moves_by_id;
  store_move_t * moves_by_name;
};
typedef struct cstore_aux_s cstore_aux_t;



typedef store_t cstore_t;




bool cstore_has( store_t * cstore, store_key_t key );
int cstore_get( store_t * cstore, store_key_t key, void ** val );
int cstore_get_str( store_t * cstore, const char *, void ** val );
int cstore_get_str_t( store_t * cstore,
                       store_type_t val_type,
                       const char * key,
                       void ** val
                     );
int cstore_init( store_t * cstore, void * pokedex );
void cstore_free( store_t * cstore );




int cstore_get_pokemon( cstore_t * cstore,
                        uint16_t dex_num,
                        uint8_t form_idx,
                        pdex_mon_t ** mon
                      );

int cstore_get_pokemon_by_name( cstore_t * cstore,
                                const char * name,
                                pdex_mon_t ** mon
                              );




int cstore_get_move( cstore_t * cstore,
                     uint16_t move_id,
                     store_move_t ** move
                   );

int cstore_get_move_by_name( cstore_t * cstore,
                             const char * name,
                             store_move_t ** move
                           );


/*
  static inline int
cstore_export( store_t * cstore,
               store_sink_t sink_type,
               void * target
             )
{
  return STORE_ERROR_NOT_DEFINED;
}

  static inline int
cstore_add( store_t * cstore, store_key_t key, void * val )
{
  return STORE_ERROR_NOT_WRITABLE;
}

  static inline int
cstore_set( store_t * cstore, store_key_t key, void * val )
{
  return STORE_ERROR_NOT_WRITABLE;
}
*/
//__FROM__: include/ai/naive_ai.h
struct pvp_battle_s;




ai_status_t naive_ai_select_team( roster_t * our_roster,
                                  roster_t * their_roser,
                                  pvp_pokemon_t * team,
                                  store_t * store,
                                  void * aux
                                );

ai_status_t naive_ai_decide_action( bool decide_p1,
                                    const struct pvp_battle_s * battle,
                                    pvp_action_t * choice,
                                    void * aux
                                  );

ai_status_t naive_ai_init( ai_t * ai, void * init_aux );
void naive_ai_free( ai_t * ai );
